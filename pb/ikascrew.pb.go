// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ikascrew.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SyncRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRequest) Reset()         { *m = SyncRequest{} }
func (m *SyncRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRequest) ProtoMessage()    {}
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{0}
}

func (m *SyncRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncRequest.Unmarshal(m, b)
}
func (m *SyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncRequest.Marshal(b, m, deterministic)
}
func (m *SyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRequest.Merge(m, src)
}
func (m *SyncRequest) XXX_Size() int {
	return xxx_messageInfo_SyncRequest.Size(m)
}
func (m *SyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRequest proto.InternalMessageInfo

type SyncReply struct {
	Source               string   `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Project              int64    `protobuf:"varint,3,opt,name=project,proto3" json:"project,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncReply) Reset()         { *m = SyncReply{} }
func (m *SyncReply) String() string { return proto.CompactTextString(m) }
func (*SyncReply) ProtoMessage()    {}
func (*SyncReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{1}
}

func (m *SyncReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncReply.Unmarshal(m, b)
}
func (m *SyncReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncReply.Marshal(b, m, deterministic)
}
func (m *SyncReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncReply.Merge(m, src)
}
func (m *SyncReply) XXX_Size() int {
	return xxx_messageInfo_SyncReply.Size(m)
}
func (m *SyncReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncReply.DiscardUnknown(m)
}

var xxx_messageInfo_SyncReply proto.InternalMessageInfo

func (m *SyncReply) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *SyncReply) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SyncReply) GetProject() int64 {
	if m != nil {
		return m.Project
	}
	return 0
}

type EffectRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Effect               string   `protobuf:"bytes,3,opt,name=effect,proto3" json:"effect,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EffectRequest) Reset()         { *m = EffectRequest{} }
func (m *EffectRequest) String() string { return proto.CompactTextString(m) }
func (*EffectRequest) ProtoMessage()    {}
func (*EffectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{2}
}

func (m *EffectRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EffectRequest.Unmarshal(m, b)
}
func (m *EffectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EffectRequest.Marshal(b, m, deterministic)
}
func (m *EffectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EffectRequest.Merge(m, src)
}
func (m *EffectRequest) XXX_Size() int {
	return xxx_messageInfo_EffectRequest.Size(m)
}
func (m *EffectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EffectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EffectRequest proto.InternalMessageInfo

func (m *EffectRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EffectRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *EffectRequest) GetEffect() string {
	if m != nil {
		return m.Effect
	}
	return ""
}

type EffectReply struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EffectReply) Reset()         { *m = EffectReply{} }
func (m *EffectReply) String() string { return proto.CompactTextString(m) }
func (*EffectReply) ProtoMessage()    {}
func (*EffectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{3}
}

func (m *EffectReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EffectReply.Unmarshal(m, b)
}
func (m *EffectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EffectReply.Marshal(b, m, deterministic)
}
func (m *EffectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EffectReply.Merge(m, src)
}
func (m *EffectReply) XXX_Size() int {
	return xxx_messageInfo_EffectReply.Size(m)
}
func (m *EffectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EffectReply.DiscardUnknown(m)
}

var xxx_messageInfo_EffectReply proto.InternalMessageInfo

func (m *EffectReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type SwitchRequest struct {
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwitchRequest) Reset()         { *m = SwitchRequest{} }
func (m *SwitchRequest) String() string { return proto.CompactTextString(m) }
func (*SwitchRequest) ProtoMessage()    {}
func (*SwitchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{4}
}

func (m *SwitchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwitchRequest.Unmarshal(m, b)
}
func (m *SwitchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwitchRequest.Marshal(b, m, deterministic)
}
func (m *SwitchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchRequest.Merge(m, src)
}
func (m *SwitchRequest) XXX_Size() int {
	return xxx_messageInfo_SwitchRequest.Size(m)
}
func (m *SwitchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchRequest proto.InternalMessageInfo

func (m *SwitchRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type SwitchReply struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwitchReply) Reset()         { *m = SwitchReply{} }
func (m *SwitchReply) String() string { return proto.CompactTextString(m) }
func (*SwitchReply) ProtoMessage()    {}
func (*SwitchReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{5}
}

func (m *SwitchReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwitchReply.Unmarshal(m, b)
}
func (m *SwitchReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwitchReply.Marshal(b, m, deterministic)
}
func (m *SwitchReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchReply.Merge(m, src)
}
func (m *SwitchReply) XXX_Size() int {
	return xxx_messageInfo_SwitchReply.Size(m)
}
func (m *SwitchReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchReply.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchReply proto.InternalMessageInfo

func (m *SwitchReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type VolumeMessage struct {
	Index                int64    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Value                float64  `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeMessage) Reset()         { *m = VolumeMessage{} }
func (m *VolumeMessage) String() string { return proto.CompactTextString(m) }
func (*VolumeMessage) ProtoMessage()    {}
func (*VolumeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{6}
}

func (m *VolumeMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeMessage.Unmarshal(m, b)
}
func (m *VolumeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeMessage.Marshal(b, m, deterministic)
}
func (m *VolumeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeMessage.Merge(m, src)
}
func (m *VolumeMessage) XXX_Size() int {
	return xxx_messageInfo_VolumeMessage.Size(m)
}
func (m *VolumeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeMessage proto.InternalMessageInfo

func (m *VolumeMessage) GetIndex() int64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *VolumeMessage) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type VolumeReply struct {
	Success              bool      `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ValueList            []float64 `protobuf:"fixed64,2,rep,packed,name=valueList,proto3" json:"valueList,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VolumeReply) Reset()         { *m = VolumeReply{} }
func (m *VolumeReply) String() string { return proto.CompactTextString(m) }
func (*VolumeReply) ProtoMessage()    {}
func (*VolumeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_9f41299d65287fb4, []int{7}
}

func (m *VolumeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeReply.Unmarshal(m, b)
}
func (m *VolumeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeReply.Marshal(b, m, deterministic)
}
func (m *VolumeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeReply.Merge(m, src)
}
func (m *VolumeReply) XXX_Size() int {
	return xxx_messageInfo_VolumeReply.Size(m)
}
func (m *VolumeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeReply.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeReply proto.InternalMessageInfo

func (m *VolumeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *VolumeReply) GetValueList() []float64 {
	if m != nil {
		return m.ValueList
	}
	return nil
}

func init() {
	proto.RegisterType((*SyncRequest)(nil), "pb.SyncRequest")
	proto.RegisterType((*SyncReply)(nil), "pb.SyncReply")
	proto.RegisterType((*EffectRequest)(nil), "pb.EffectRequest")
	proto.RegisterType((*EffectReply)(nil), "pb.EffectReply")
	proto.RegisterType((*SwitchRequest)(nil), "pb.SwitchRequest")
	proto.RegisterType((*SwitchReply)(nil), "pb.SwitchReply")
	proto.RegisterType((*VolumeMessage)(nil), "pb.VolumeMessage")
	proto.RegisterType((*VolumeReply)(nil), "pb.VolumeReply")
}

func init() { proto.RegisterFile("ikascrew.proto", fileDescriptor_9f41299d65287fb4) }

var fileDescriptor_9f41299d65287fb4 = []byte{
	// 338 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0x4f, 0x4f, 0xfa, 0x40,
	0x10, 0xa5, 0x94, 0x5f, 0xa1, 0x43, 0xfa, 0x23, 0x6e, 0x0c, 0x69, 0x88, 0x07, 0xb2, 0x1e, 0xec,
	0xa9, 0x89, 0x7a, 0xf4, 0xcc, 0xc1, 0x44, 0xa3, 0x2e, 0x89, 0xf7, 0xb2, 0x0e, 0x5a, 0x2d, 0xed,
	0xda, 0xdd, 0x8a, 0xfd, 0x84, 0x7e, 0x2d, 0xd3, 0xdd, 0x56, 0x16, 0x63, 0xf4, 0xb6, 0x6f, 0x78,
	0x7f, 0x98, 0x79, 0x85, 0xff, 0xe9, 0x4b, 0x22, 0x79, 0x89, 0xdb, 0x58, 0x94, 0x85, 0x2a, 0x48,
	0x5f, 0xac, 0x68, 0x00, 0xe3, 0x65, 0x9d, 0x73, 0x86, 0xaf, 0x15, 0x4a, 0x45, 0xef, 0xc0, 0x37,
	0x50, 0x64, 0x35, 0x99, 0x82, 0x27, 0x8b, 0xaa, 0xe4, 0x18, 0x3a, 0x73, 0x27, 0xf2, 0x59, 0x8b,
	0x08, 0x81, 0x81, 0xaa, 0x05, 0x86, 0x7d, 0x3d, 0xd5, 0x6f, 0x12, 0xc2, 0x50, 0x94, 0xc5, 0x33,
	0x72, 0x15, 0xba, 0x73, 0x27, 0x72, 0x59, 0x07, 0xe9, 0x0d, 0x04, 0x8b, 0xf5, 0x1a, 0xb9, 0x6a,
	0x33, 0x1a, 0x79, 0x9e, 0x6c, 0x3a, 0x53, 0xfd, 0xfe, 0xd1, 0x72, 0x0a, 0x1e, 0x6a, 0xa1, 0x76,
	0xf4, 0x59, 0x8b, 0xe8, 0x09, 0x8c, 0x3b, 0xc3, 0xe6, 0x5f, 0x86, 0x30, 0x94, 0x15, 0xe7, 0x28,
	0xa5, 0x76, 0x1c, 0xb1, 0x0e, 0xd2, 0x63, 0x08, 0x96, 0xdb, 0x54, 0xf1, 0x27, 0x2b, 0xf9, 0x7b,
	0x4a, 0xe3, 0xd6, 0x91, 0x7e, 0x77, 0xbb, 0x80, 0xe0, 0xbe, 0xc8, 0xaa, 0x0d, 0x5e, 0xa3, 0x94,
	0xc9, 0x23, 0x92, 0x43, 0xf8, 0x97, 0xe6, 0x0f, 0xf8, 0xae, 0x89, 0x2e, 0x33, 0xa0, 0x99, 0xbe,
	0x25, 0x59, 0x65, 0x42, 0x1c, 0x66, 0x00, 0x5d, 0xc0, 0xd8, 0x88, 0xff, 0x48, 0x21, 0x47, 0xe0,
	0x6b, 0xc5, 0x55, 0x2a, 0x55, 0xd8, 0x9f, 0xbb, 0x91, 0xc3, 0x76, 0x83, 0xb3, 0x0f, 0x07, 0x46,
	0x97, 0x6d, 0x89, 0x24, 0x82, 0x41, 0xd3, 0x15, 0x99, 0xc4, 0x62, 0x15, 0x5b, 0x25, 0xce, 0x82,
	0xdd, 0x40, 0x64, 0x35, 0xed, 0x91, 0x18, 0x3c, 0xb3, 0x23, 0x39, 0xd0, 0x3f, 0xd9, 0x47, 0x99,
	0x4d, 0xec, 0xd1, 0x17, 0xdf, 0x5c, 0xd8, 0xf0, 0xf7, 0xea, 0x33, 0x7c, 0xab, 0x00, 0xda, 0x23,
	0xa7, 0xe0, 0xdf, 0x56, 0xca, 0x2c, 0x68, 0x24, 0x7b, 0x97, 0x32, 0x12, 0x6b, 0x7f, 0xda, 0x5b,
	0x79, 0xfa, 0x13, 0x3c, 0xff, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x10, 0x62, 0x70, 0x8b, 0x94, 0x02,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// IkascrewClient is the client API for Ikascrew service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IkascrewClient interface {
	Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncReply, error)
	Switch(ctx context.Context, in *SwitchRequest, opts ...grpc.CallOption) (*SwitchReply, error)
	Effect(ctx context.Context, in *EffectRequest, opts ...grpc.CallOption) (*EffectReply, error)
	PutVolume(ctx context.Context, in *VolumeMessage, opts ...grpc.CallOption) (*VolumeReply, error)
}

type ikascrewClient struct {
	cc grpc.ClientConnInterface
}

func NewIkascrewClient(cc grpc.ClientConnInterface) IkascrewClient {
	return &ikascrewClient{cc}
}

func (c *ikascrewClient) Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncReply, error) {
	out := new(SyncReply)
	err := c.cc.Invoke(ctx, "/pb.Ikascrew/Sync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ikascrewClient) Switch(ctx context.Context, in *SwitchRequest, opts ...grpc.CallOption) (*SwitchReply, error) {
	out := new(SwitchReply)
	err := c.cc.Invoke(ctx, "/pb.Ikascrew/Switch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ikascrewClient) Effect(ctx context.Context, in *EffectRequest, opts ...grpc.CallOption) (*EffectReply, error) {
	out := new(EffectReply)
	err := c.cc.Invoke(ctx, "/pb.Ikascrew/Effect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ikascrewClient) PutVolume(ctx context.Context, in *VolumeMessage, opts ...grpc.CallOption) (*VolumeReply, error) {
	out := new(VolumeReply)
	err := c.cc.Invoke(ctx, "/pb.Ikascrew/PutVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IkascrewServer is the server API for Ikascrew service.
type IkascrewServer interface {
	Sync(context.Context, *SyncRequest) (*SyncReply, error)
	Switch(context.Context, *SwitchRequest) (*SwitchReply, error)
	Effect(context.Context, *EffectRequest) (*EffectReply, error)
	PutVolume(context.Context, *VolumeMessage) (*VolumeReply, error)
}

// UnimplementedIkascrewServer can be embedded to have forward compatible implementations.
type UnimplementedIkascrewServer struct {
}

func (*UnimplementedIkascrewServer) Sync(ctx context.Context, req *SyncRequest) (*SyncReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (*UnimplementedIkascrewServer) Switch(ctx context.Context, req *SwitchRequest) (*SwitchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Switch not implemented")
}
func (*UnimplementedIkascrewServer) Effect(ctx context.Context, req *EffectRequest) (*EffectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Effect not implemented")
}
func (*UnimplementedIkascrewServer) PutVolume(ctx context.Context, req *VolumeMessage) (*VolumeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutVolume not implemented")
}

func RegisterIkascrewServer(s *grpc.Server, srv IkascrewServer) {
	s.RegisterService(&_Ikascrew_serviceDesc, srv)
}

func _Ikascrew_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IkascrewServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Ikascrew/Sync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IkascrewServer).Sync(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ikascrew_Switch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IkascrewServer).Switch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Ikascrew/Switch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IkascrewServer).Switch(ctx, req.(*SwitchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ikascrew_Effect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EffectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IkascrewServer).Effect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Ikascrew/Effect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IkascrewServer).Effect(ctx, req.(*EffectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ikascrew_PutVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IkascrewServer).PutVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Ikascrew/PutVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IkascrewServer).PutVolume(ctx, req.(*VolumeMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ikascrew_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Ikascrew",
	HandlerType: (*IkascrewServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Sync",
			Handler:    _Ikascrew_Sync_Handler,
		},
		{
			MethodName: "Switch",
			Handler:    _Ikascrew_Switch_Handler,
		},
		{
			MethodName: "Effect",
			Handler:    _Ikascrew_Effect_Handler,
		},
		{
			MethodName: "PutVolume",
			Handler:    _Ikascrew_PutVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ikascrew.proto",
}
